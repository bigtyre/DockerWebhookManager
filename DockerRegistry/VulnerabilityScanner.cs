using DockerRegistry.Configuration;
using DockerRegistryUI;
using DockerRegistryUI.Data;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using System.Threading;
using TrivyAPIClient;

namespace DockerRegistry;

public class VulnerabilityScanner(
        DockerImageUrlBuilder dockerImageUrlBuilder,
        RegistrySettings settings,
        TrivyApiClient trivyApiClient,
        VulnerabilityScanRepository vulnerabilityScanRepository,
        ILogger<VulnerabilityScanner> logger,
        RegistryService registryService
    )
{
    public const long MaxScanSizeInBytes = 1024 * 1024 * 1024; // 1 GB max scan size

    public async Task<TrivyScanResult> ScanAsync(string repositoryName, string tagName, CancellationToken cancellationToken = default)
    {
        var imageUrl = dockerImageUrlBuilder.GetImageUrl(repositoryName, tagName);
        logger.LogInformation("Running vulnerability scan on {imageUrl}", imageUrl);

        // Check the repository size. We should skip scanning repositories which are large
        var manifest = await registryService.GetManifestV2Async(repositoryName, tagName, cancellationToken);
        var totalSizeInBytes = manifest.Layers.Sum(s => s.Size);
        if (totalSizeInBytes > MaxScanSizeInBytes)
        {
            var maxScanSizeInMb = MaxScanSizeInBytes / 1024 / 1024;
            throw new InvalidOperationException($"Cannot scan this image. Image exceeds the maximum scan size on {maxScanSizeInMb} MB");
        }

        var result = await trivyApiClient.GetScanResultAsync(imageUrl.ToString(), settings.Username, settings.Password);
        logger.LogInformation("Got vulnerability scan results for {imageUrl}", imageUrl);


        _ = Task.Run(async () =>
        {
            try
            {
                var numVulnerabilities = result.Results.SelectMany(c => c.Vulnerabilities).Count();

                logger.LogInformation("Recording vulnerability scan results for {imageUrl}. # Vulnerabilities found: {numVulnerabilities}", imageUrl, numVulnerabilities);
                await vulnerabilityScanRepository.RecordScanResultAsync(result);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Failed to record vulnerability result: {ex}", ex.Message);
            }
        }, cancellationToken);

        return result;
    }


}

public record MySqlSettings(string ConnectionString);

public record VulnerabilityCounts(int Critical, int High, int Medium, int Low, int Unknown);

public class VulnerabilityScanRepository(
    DockerImageUrlBuilder dockerImageUrlBuilder,
    VulnerabilityDbContextFactory dbContextFactory
)
{
    private static readonly TimeSpan _storageTimeZone = TimeSpan.FromHours(10);
    private readonly DockerImageUrlBuilder _dockerImageUrlBuilder = dockerImageUrlBuilder;

    /// <summary>
    /// Fetches counts of the vulnerabilities against an image tag grouped by severity.
    /// </summary>
    /// <param name="tagNames"></param>
    /// <returns></returns>
    public async Task<Dictionary<string, VulnerabilityCounts>> GetLatestVulnerabilityCountsAsync(IEnumerable<RepositoryTag> tagNames)
    {
        var dbContext = dbContextFactory.Create();

        var results = new Dictionary<string, VulnerabilityCounts>();

        var tagNamesList = tagNames.Select(c => _dockerImageUrlBuilder.GetImageUrl(c.RepositoryName, c.TagName).WithoutScheme().ToString()).ToList();

        var latestVulnerabilityScans = await dbContext
            .VulnerabilityScans
            .Where(c => tagNamesList.Contains(c.Image))
            .Where(c => !dbContext.VulnerabilityScans.Any(d => d.Id != c.Id && d.Image == c.Image && d.ScanDate > c.ScanDate))
            .GroupBy(c => c.Image)
            .Select(c => new
            {
                Image = c.Key,
                ScanId = c.First().Id
            })
            .ToListAsync();

        var scanIds = latestVulnerabilityScans.Select(c => c.ScanId).Distinct().ToList();

        var counts = await dbContext.Vulnerabilities.Where(c =>
            scanIds.Contains(c.ScanId))
            .GroupBy(c => new { c.ScanId, c.Severity })
            .Select(c => new
            {
                c.Key.ScanId,
                c.Key.Severity,
                Count = c.Count()
            })
            .ToListAsync();

        var countsByScanId = counts.GroupBy(c => c.ScanId).ToDictionary(c => c.Key, c => c);

        foreach (var pair in latestVulnerabilityScans)
        {
            var image = pair.Image;
            var scanId = pair.ScanId;

            int critical = 0;
            int high = 0;
            int medium = 0;
            int low = 0;
            int unknown = 0;

            if (countsByScanId.TryGetValue(scanId, out var countsBySeverity) is false)
                continue;

            foreach (var c in countsBySeverity)
            {
                var severity = c.Severity;
                if (string.Equals(severity, "Critical", StringComparison.OrdinalIgnoreCase))
                    critical = c.Count;
                else if (string.Equals(severity, "High", StringComparison.OrdinalIgnoreCase))
                    high = c.Count;
                else if (string.Equals(severity, "Medium", StringComparison.OrdinalIgnoreCase))
                    medium = c.Count;
                else if (string.Equals(severity, "Low", StringComparison.OrdinalIgnoreCase))
                    low = c.Count;
                else if (string.Equals(severity, "Unknown", StringComparison.OrdinalIgnoreCase))
                    unknown = c.Count;
            }

            var vulnerabilityCount = new VulnerabilityCounts(critical, high, medium, low, unknown);

            results[image] = vulnerabilityCount;
        }
        /*
        // Get the latest count of vulnerabilities for each image
        var vulnerabilityCounts = await dbContext
            .VulnerabilityScans
            .Where(c => tagNamesList.Contains(c.Image))
            .Where(c => !dbContext.VulnerabilityScans.Any(d => d.Id != c.Id && d.Image == c.Image && d.ScanDate > c.ScanDate))
            .GroupBy(c => c.Image)
            .Select(c => new
            {
                Image = c.Key,
                Critical = c.First().Vulnerabilities.Count(c => c.Severity == "Critical"),
                High = c.First().Vulnerabilities.Count(c => c.Severity == "High"),
                Medium = c.First().Vulnerabilities.Count(c => c.Severity == "Medium"),
                Low = c.First().Vulnerabilities.Count(c => c.Severity == "Low"),
                Unknown = c.First().Vulnerabilities.Count(c => c.Severity == "Unknown"),
            })
            .ToListAsync();

        // Convert it to a dictinary of the right type
        results = vulnerabilityCounts.ToDictionary(
            s => s.Image,
            s => new VulnerabilityCounts(s.Critical, s.High, s.Medium, s.Low, s.Unknown)
        );
        */
        return results;
    }

    public async Task RecordScanResultAsync(TrivyScanResult result)
    {
        var dbContext = dbContextFactory.Create();

        // Create a new scan entry
        var scan = new SavedVulnerabilityScan(result.ArtifactName, DateTime.UtcNow.Add(_storageTimeZone));

        List<VulnerabilityDescription> newDescriptions = [];


        var vulnerabilities = result.Results.SelectMany(r => r.Vulnerabilities).ToList();

        // Calculate the has for each unique description in the vulnerabilities
        var descriptionHashes = vulnerabilities
            .Select(c => c.Description)
            .Distinct()
            .Where(c => c != null)
            .Cast<string>()
            .ToDictionary(s => s, HashHelper.ComputeSha256Hash);

        // Get the unique hash values (in case there are multiple descriptions which hash to the same value)
        var allHashes = descriptionHashes.Values.Distinct().ToList();

        // Find any/all existing descriptions which match the description hashes of the full set of vulnerabilities
        var existingDescriptions = await dbContext
            .VulnerabilityDescriptions
            .Where(c => allHashes.Contains(c.DescriptionHash))
            .ToListAsync();

        // Group the existing descriptions by hash value for easy lookups
        var existingDescriptionsByHash = existingDescriptions
            .GroupBy(c => c.DescriptionHash)
            .ToDictionary(c => c.Key, c => c.ToList());

        foreach (var v in vulnerabilities)
        {
            VulnerabilityDescription? description = null;
            var descriptionText = v.Description;
            if (!string.IsNullOrEmpty(descriptionText))
            {
                description = newDescriptions.FirstOrDefault(c => c.DescriptionText == descriptionText);
                if (description is null)
                {
                    var descriptionHash = HashHelper.ComputeSha256Hash(descriptionText);

                    if (existingDescriptionsByHash.TryGetValue(descriptionHash, out var possibleDescriptions))
                    {
                        foreach (var d in possibleDescriptions)
                        {
                            if (d.DescriptionText == descriptionText)
                            {
                                description = d;
                                break;
                            }
                        }
                    }

                    // var desc = await dbContext.VulnerabilityDescriptions.Where(d => d.DescriptionHash == descriptionHash).ToListAsync();
                    // description = desc.FirstOrDefault(c => c.DescriptionText == descriptionText);

                    if (description is null)
                    {
                        var d = new VulnerabilityDescription(
                            descriptionHash: descriptionHash,
                            descriptionText: descriptionText
                        );
                        newDescriptions.Add(d);

                        dbContext.Add(d);
                        await dbContext.SaveChangesAsync();

                        description = d;
                    }
                }
            }

            var vulnerability = new SavedVulnerability
            {
                VulnerabilityId = v.VulnerabilityID,
                PackageName = v.PkgName,
                InstalledVersion = v.InstalledVersion,
                FixedVersion = v.FixedVersion,
                Severity = v.Severity,
                VulnerabilityDescriptionId = description?.Id
            };

            scan.Vulnerabilities.Add(vulnerability);
        }

        // Save to database
        await dbContext.VulnerabilityScans.AddAsync(scan);
        await dbContext.SaveChangesAsync();
    }

    public async Task<SavedVulnerabilityScan?> GetLatestScanWithVulnerabilitiesAsync(string image)
    {
        var dbContext = dbContextFactory.Create();

        return await dbContext.VulnerabilityScans
            .Include(vs => vs.Vulnerabilities)
                .ThenInclude(c => c.Description)
            .OrderByDescending(vs => vs.ScanDate)
            .FirstOrDefaultAsync(c => c.Image == image);
    }

    public async Task<List<VulnerabilityScanSummary>> GetVulnerabilityScansAsync(string? image = null)
    {
        var dbContext = dbContextFactory.Create();

        var scans = dbContext.VulnerabilityScans.AsQueryable();

        if (image is not null)
        {
            scans = scans.Where(c => c.Image == image);
        }


        return await scans
            .OrderByDescending(vs => vs.ScanDate)
            .Select(c => new VulnerabilityScanSummary(c.Id, c.Image, c.ScanDate))
            .ToListAsync();
    }
}
