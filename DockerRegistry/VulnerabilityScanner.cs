using DockerRegistry.Configuration;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Logging;
using TrivyAPIClient;

namespace DockerRegistryUI.Data;

public class VulnerabilityScanner(
        DockerImageUrlBuilder dockerImageUrlBuilder,
        RegistrySettings settings,
        TrivyApiClient trivyApiClient,
        VulnerabilityScanRepository vulnerabilityScanRepository,
        ILogger<VulnerabilityScanner> logger
    )
{
    public async Task<TrivyScanResult> ScanAsync(string repositoryName, string tagName)
    {
        var imageUrl = dockerImageUrlBuilder.GetImageUrl(repositoryName, tagName);
        logger.LogInformation("Running vulnerability scan on {imageUrl}", imageUrl);

        var result = await trivyApiClient.GetScanResultAsync(imageUrl.ToString(), settings.Username, settings.Password);
        logger.LogInformation("Got vulnerability scan results for {imageUrl}", imageUrl);


        _ = Task.Run(async () =>
        {
            try
            {
                var numVulnerabilities = result.Results.SelectMany(c => c.Vulnerabilities).Count();

                logger.LogInformation("Recording vulnerability scan results for {imageUrl}. # Vulnerabilities found: {numVulnerabilities}", imageUrl, numVulnerabilities);
                await vulnerabilityScanRepository.RecordScanResultAsync(result);
            }
            catch (Exception ex)
            {
                logger.LogError(ex, "Failed to record vulnerability result: {ex}", ex.Message);
            }
        });

        return result;
    }

    
}

public record MySqlSettings(string ConnectionString);

public record VulnerabilityCounts(int Critical, int High, int Medium, int Low, int Unknown);

public class VulnerabilityScanRepository(
    DockerImageUrlBuilder dockerImageUrlBuilder,
    VulnerabilityDbContextFactory dbContextFactory,
    ILogger<VulnerabilityScanRepository> logger
)
{
    private static readonly TimeSpan _storageTimeZone = TimeSpan.FromHours(10);
    private readonly DockerImageUrlBuilder _dockerImageUrlBuilder = dockerImageUrlBuilder;

    /// <summary>
    /// Fetches counts of the vulnerabilities against an image tag grouped by severity.
    /// </summary>
    /// <param name="tagNames"></param>
    /// <returns></returns>
    public async Task<Dictionary<string, VulnerabilityCounts>> GetLatestVulnerabilityCountsAsync(IEnumerable<RepositoryTag> tagNames)
    {
        var dbContext = dbContextFactory.Create();

        var results = new Dictionary<string, VulnerabilityCounts>();

        var tagNamesList = tagNames.Select(c => UrlExtensions.WithoutScheme(_dockerImageUrlBuilder.GetImageUrl(c.RepositoryName, c.TagName)).ToString()).ToList();

        // Get the latest count of vulnerabilities for each image
        var vulnerabilityCounts = await dbContext
            .VulnerabilityScans
            .Where(c => tagNamesList.Contains(c.Image))
            .Where(c => !dbContext.VulnerabilityScans.Any(d => d.Id != c.Id && d.Image == c.Image && d.ScanDate > c.ScanDate))
            .GroupBy(c => c.Image)
            .Select(c => new
            {
                Image = c.Key,
                Critical = c.First().Vulnerabilities.Count(c => c.Severity == "Critical"),
                High = c.First().Vulnerabilities.Count(c => c.Severity == "High"),
                Medium = c.First().Vulnerabilities.Count(c => c.Severity == "Medium"),
                Low = c.First().Vulnerabilities.Count(c => c.Severity == "Low"),
                Unknown = c.First().Vulnerabilities.Count(c => c.Severity == "Unknown"),
            })
            .ToListAsync();

        // Convert it to a dictinary of the right type
        results = vulnerabilityCounts.ToDictionary(
            s => s.Image,
            s => new VulnerabilityCounts(s.Critical, s.High, s.Medium, s.Low, s.Unknown)
        );

        return results;
    }

    public async Task RecordScanResultAsync(TrivyScanResult result)
    {
        var dbContext = dbContextFactory.Create();

        // Create a new scan entry
        var scan = new SavedVulnerabilityScan(result.ArtifactName, DateTime.UtcNow.Add(_storageTimeZone));

        List<VulnerabilityDescription> newDescriptions = [];


        var vulnerabilities = result.Results.SelectMany(r => r.Vulnerabilities).ToList();

        // Calculate the has for each unique description in the vulnerabilities
        var descriptionHashes = vulnerabilities
            .Select(c => c.Description)
            .Distinct()
            .Where(c => c != null)
            .Cast<string>()
            .ToDictionary(s => s, HashHelper.ComputeSha256Hash);

        // Get the unique hash values (in case there are multiple descriptions which hash to the same value)
        var allHashes = descriptionHashes.Values.Distinct().ToList();

        // Find any/all existing descriptions which match the description hashes of the full set of vulnerabilities
        var existingDescriptions = await dbContext
            .VulnerabilityDescriptions
            .Where(c => allHashes.Contains(c.DescriptionHash))
            .ToListAsync();

        // Group the existing descriptions by hash value for easy lookups
        var existingDescriptionsByHash = existingDescriptions
            .GroupBy(c => c.DescriptionHash)
            .ToDictionary(c => c.Key, c => c.ToList());

        foreach (var v in vulnerabilities)
        {
            VulnerabilityDescription? description = null;
            var descriptionText = v.Description;
            if (!string.IsNullOrEmpty(descriptionText))
            {
                description = newDescriptions.FirstOrDefault(c => c.DescriptionText == descriptionText);
                if (description is null)
                {
                    var descriptionHash = HashHelper.ComputeSha256Hash(descriptionText);

                    if (existingDescriptionsByHash.TryGetValue(descriptionHash, out var possibleDescriptions))
                    {
                        foreach (var d in  possibleDescriptions)
                        {
                            if (d.DescriptionText == descriptionText)
                            {
                                description = d;
                                break;
                            }
                        }
                    }

                   // var desc = await dbContext.VulnerabilityDescriptions.Where(d => d.DescriptionHash == descriptionHash).ToListAsync();
                   // description = desc.FirstOrDefault(c => c.DescriptionText == descriptionText);

                    if (description is null)
                    {
                        var d = new VulnerabilityDescription(
                            descriptionHash: descriptionHash, 
                            descriptionText: descriptionText
                        );
                        newDescriptions.Add(d);

                        dbContext.Add(d);
                        await dbContext.SaveChangesAsync();

                        description = d;
                    }
                }
            }

            var vulnerability = new SavedVulnerability
            {
                VulnerabilityId = v.VulnerabilityID,
                PackageName = v.PkgName,
                InstalledVersion = v.InstalledVersion,
                FixedVersion = v.FixedVersion,
                Severity = v.Severity,
                VulnerabilityDescriptionId = description?.Id
            };

            scan.Vulnerabilities.Add(vulnerability);
        }

        // Save to database
        await dbContext.VulnerabilityScans.AddAsync(scan);
        await dbContext.SaveChangesAsync();
    }

    public async Task<SavedVulnerabilityScan?> GetLatestScanWithVulnerabilitiesAsync(string image)
    {
        var dbContext = dbContextFactory.Create();

        return await dbContext.VulnerabilityScans
            .Include(vs => vs.Vulnerabilities)
                .ThenInclude(c => c.Description)
            .OrderByDescending(vs => vs.ScanDate)
            .FirstOrDefaultAsync(c => c.Image == image);
    }

    public async Task<List<VulnerabilityScanSummary>> GetVulnerabilityScansAsync(string? image = null)
    {
        var dbContext = dbContextFactory.Create();

        var scans = dbContext.VulnerabilityScans.AsQueryable();

        if (image is not null)
        {
            scans = scans.Where(c => c.Image == image);
        }

            
        return await scans
            .OrderByDescending(vs => vs.ScanDate)
            .Select(c => new VulnerabilityScanSummary(c.Id, c.Image, c.ScanDate))
            .ToListAsync();
    }
}
