using DockerRegistry;
using DockerRegistryUI.Data;
using Microsoft.Extensions.Hosting;
using Prometheus;
using System;
    using System.Collections.Generic;
    using System.Diagnostics.Metrics;
using System.Reflection.Metadata.Ecma335;
using System.Threading;
    using System.Threading.Tasks;
using static Mysqlx.Error.Types;
namespace DockerRegistryUI.BackgroundServiceStatus
{

    public class VulnerabilityMetricsService(
        RegistryService registry,
        VulnerabilityScanRepository vulnerabilityScanRepository,
        DockerImageUrlBuilder dockerImageUrlBuilder,
        ILogger<VulnerabilityMetricsService> logger
        ) : BackgroundService
    {
        private readonly Gauge _vulnerabilityGauge = Metrics.CreateGauge(
            "docker_image_vulnerabilities",
            "Number of vulnerabilities for Docker images by severity",
            new GaugeConfiguration
            {
                LabelNames = ["image", "tag", "severity"]
            });

        protected override async Task ExecuteAsync(CancellationToken cancellationToken)
        {
            var metricsUpdateInterval = TimeSpan.FromMinutes(15);

            while (!cancellationToken.IsCancellationRequested)
            {
                // Using a linked token source here as I'm considering allowing the update interval to be interrupted and fast-tracked if a scan is detected.
                using var cancellationTokenSource = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
                var cancelToken = cancellationTokenSource.Token;

                try
                {
                    await UpdateMetricsAsync(cancellationToken);
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error while updating vulnerability metrics: {errorMessage}", ex.Message);
                }

                await Task.Delay(metricsUpdateInterval, cancelToken);
            }
        }

        private async Task UpdateMetricsAsync(CancellationToken cancellationToken = default)
        {
            var repositories = await registry.GetRepositoriesAsync(cancellationToken);

            // Currently just checking latest. Could consider iterating and checking all tags.
            var repositoryTags = repositories.Select(c => new RepositoryTag(c.Name, "latest")).ToList();
            
            var counts = await vulnerabilityScanRepository.GetLatestVulnerabilityCountsAsync(repositoryTags);

            foreach (var tag in repositoryTags)
            {
                var repositoryName = tag.RepositoryName;
                var tagName = tag.TagName;

                var image = dockerImageUrlBuilder.GetImageUrl(repositoryName, tagName).WithoutScheme();

                if (counts.TryGetValue(image, out var count) is false)
                    continue;

                _vulnerabilityGauge.WithLabels(repositoryName, tagName, "Critical").Set(count.Critical);
                _vulnerabilityGauge.WithLabels(repositoryName, tagName, "High").Set(count.High);
                _vulnerabilityGauge.WithLabels(repositoryName, tagName, "Medium").Set(count.Medium);
                _vulnerabilityGauge.WithLabels(repositoryName, tagName, "Low").Set(count.Low);
                _vulnerabilityGauge.WithLabels(repositoryName, tagName, "Unknown").Set(count.Unknown);

            }

            Console.WriteLine("Metrics updated.");
        }
    }
}
