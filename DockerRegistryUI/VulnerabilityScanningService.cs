
using DockerRegistry;
using DockerRegistryUI.Data;

namespace DockerRegistryUI
{
    public class VulnerabilityScanningService(
        ILogger<VulnerabilityScanningService> logger, 
        RegistryService registry, 
        VulnerabilityScanner vulnerabilityScanner
    ) : BackgroundService
    {
        private static readonly TimeSpan scanInterval = TimeSpan.FromHours(6);

        public VulnerabilityScanner VulnerabilityScanner { get; } = vulnerabilityScanner;

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            var cancellationToken = stoppingToken;

            logger.LogInformation($"{nameof(VulnerabilityScanningService)} started");
            try
            {
                logger.LogInformation($"Waiting 15 minutes before first vulnerability scan cycle");
                await Task.Delay(TimeSpan.FromMinutes(15), cancellationToken);

                while (!cancellationToken.IsCancellationRequested)
                {

                    logger.LogInformation($"Vulnerability scan cycle started");
                    try
                    {
                        await ScanAllRepositoriesForVulnerabilities(cancellationToken);
                    }
                    catch (Exception ex)
                    {
                        logger.LogError(ex, "Error in vulnerability scan cycle: {errorMessage}", ex.Message);

                    }
                    finally
                    {
                        logger.LogInformation($"Vulnerability scan cycle finished.");
                    }

                    await Task.Delay(scanInterval, cancellationToken);
                }
            }
            finally
            {
                logger.LogInformation($"{nameof(VulnerabilityScanningService)} stopped");
            }

        }

        private async Task ScanAllRepositoriesForVulnerabilities(CancellationToken cancellationToken = default)
        {
            var repositories = (await registry.GetRepositoriesAsync()).OrderBy(c => c.Name).ToList();

            var numRepositories = repositories.Count;

            var maxScanSize = VulnerabilityScanner.MaxScanSizeInBytes;
            var maxScanSizeInMb = maxScanSize / 1024 / 1024;

            logger.LogDebug("Scanning {numRepositories} repositor{pluralization} for vulnerabilities.", numRepositories, (numRepositories == 1 ? "y" : "ies"));
            int i = 0;
            foreach (var repository in repositories)
            {
                if (cancellationToken.IsCancellationRequested)
                    break;

                i++;
                var repositoryName = repository.Name;
                try
                {
                    var tag = "latest";

                    logger.LogDebug("Scanning repository {repositoryName}:{tag} for vulnerabilities ({i}/{numRepositories})", repositoryName, tag, i, numRepositories);

                    // Check the repository size. We should skip scanning repositories which are large
                    var manifest = await registry.GetManifestV2Async(repositoryName, tag, cancellationToken);
                    var totalSizeInBytes = manifest.Layers.Sum(s => s.Size);
                    
                    if (totalSizeInBytes > maxScanSize)
                    {
                        logger.LogDebug("Skipped scanning image. Image exceeds the maximum scan size on {maxScanSizeInMb} MB", maxScanSizeInMb);
                        continue;
                    }

                    await VulnerabilityScanner.ScanAsync(repositoryName, tag, cancellationToken);
                }
                catch (Exception ex)
                {
                    logger.LogError(ex, "Error while scanning repository {repositoryName} for vulnerabilities: {errorMessage}", repositoryName, ex.Message);
                }
            }
        }
    }
}
